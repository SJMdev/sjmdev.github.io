
=======
# Ideas about programming

## Object Oriented Programming vs. Data Oriented Programming
There is a very interesting dichotomy in modern computing science (or even a schism from the OOP church). Object Oriented Programming is taught as the de facto standard for modern programming in general (as well as modern programming languages). However, It seems that often, the rigorous attachment to the OOP paradigm can lead to unfortunate situations, where practically solving a problem (i.e. "engineering" a solution) becomes secondhand towards the implementation style.  Elements of Object Oriented Programming can be very useful, such as inheritance, especially in cases such as GUI programming. An example of this is where some system will provide a base class `Button`, from which the user can derive other buttons, with different implementations based on the `virtual` (c++ term) methods in the base class, such as `onClick()`. While it can still be used as a button (as the new class is "implemented in terms of a" button), the effects that happen when clicking on the button can be implemented in a simple way. Furthermore, the idea of message passing between `Objects` (not objects in the programming term, but instances of different classes) allows the user to create a management dynamic (or a flow chart). However, OOP also comes at a cost: users will need to structure their program before starting to implement classes. Users will need to decide what scopes certain objects live in, so that they can communicate with other objects, and which objects carry responsibility for different parts of the implementation. However, I have always felt that eventually, this becomes a major roadblock in fast iteration: because objects live in a certain scope, and only provide certain functionality, their effectiveness is limited. While we can extend their usefulness by adding new methods or new fields (or placing them in a different scope), the structure of the program changes as well. Furthermore, maybe some responsibilities change over time of some objects. This to me leads me to believe that adhering to such a rigorous structure can hinder quick progression. Furthermore, because functionality like functions are now hidden within objects, we will need to instantiate an object in order to use those functions (or deal with static member functions of the class, or worse, trying to implement a singleton). In practical terms, this would mean dealing with an allocation on the stack (nitpicking, I know), or throwing stateful objects around between different functions. 

Another problem that I personally ran into is hierarchy problems, where certain objects are members of other objects. If your application does not have proper structure, a recurring problem will be that a data member will need access to another member of the class it is a member of. This means we do not only need to provide downstream information, but also upstream information requests. This very quickly leads to hacky implementations and weird state structures implemented outside of the class. This is of course also due to inexperience, but it can still be a problem for users, even if they know how to solve the problem at hand (so this is an __implementational__ detail).

Lastly, and this is a problem that I am unsure whether or not is fixable, is member accessors (or non-member accessors even). The Idea that a `class` object can contain immutable fields (i.e. `private`) is a clever idea: it means that the object can either carry hidden state that the users needs / wants to be shielded from. Furthermore, it allows a class to define member functions that only itself can use to operate on its own data, exposing an API that the user can use in order to interface with the object, but allowing for better control flow / logical structuring of the actual behavior that the API provides. However, it also seems that this idea of limiting access to an object originates from the idea that users do not know what do to with your object, and need to explicitly (or implicitly!) be told what and what NOT to do with the class. However, to me, it feels unnecessary to access fields such as `size` via a member function called `size()`. While the member function probably has guarantees that it will not change the member field itself (i.e. `size_t getSize() const;`) changing the size of, for example, a `string` in this way will lead to undefined behavior. The argument thus becomes: make it as hard as possible to shoot yourself in the foot. I think this has merit when you have to work in a large team, where not everyone is up-to-date or concerned with your specific part of the application, and thus the rules about any particular class are implicit within the usage of the class. However, it provides a lot of overhead (in my opinion) dealing with eventual stupidity of users. More concisely: you are not worrying about solving any particular problem with your code, but are more concerned with everything BUT solving the problem that the program should solve. 

Of course, there are more arguments to be made against object oriented programming, but most of them are implementational details (at least in the c++ camp of things). While for me, the problems that arise from the implementation are never problems I experience, I can understand the resistance against it.

I do want to admit that Object Oriented Programming in c++ is immensely useful in some circumstances, because of `RAII` (resource acquisition is initialization). Because an object will be destroyed when it leaves the scope, we can directly manage what happens when the objects destructor is called (`~Object()`), which makes writing code that deals with memory and files a lot more managable than it ever was in C. At least, for me.


## Data oriented programming

The gist of the idea is that the data is and must be a first-class citizen. Dealing with data properly will result in correct, clean and fast code. Memory management is thus one of the first concerns. In most cases, people do not even want to touch or think about memory management: it is something that the user would like the computer to deal with. The problem is that I understand this mentality very clearly: it feels like bikeshedding trying to manage your own memory, when the underlying architecture can manage memory perfectly fine. I personally am a advocate for "make it work, then make it fast", but memory layout is such a fundamental / architectural problem, that you need to think about it beforehand. I also want to mention that most of the time, for most problems, memory management is not an issue that the user even needs to think about, if the problem is simplistic enough. However, in some cases, where high performance is warranted / needed/ required, it is a very beneficial way of structuring your program. I do believe that performance is correctness, but only to a certain degree. People use c++ instead of c because some of the memory management is simplified and/or abstracted in such a way that for a minimal cost, the user gets so much more peace of mind in return. However, the patterns that yield from "performance is correctness" can still be applied in modern c++: preallocating a vector and then inserting is about 80-100% faster then just using `push_back()`. Changing the allocator to grow even greedier than exponential ( instead of size * 2, size * 3.3) also has meaningful impact on insertion speed. I personally very much enjoy the addition of the STL and its useful container types: it allows me to not worry about memory, allocation on the heap and pointers, all of which simplify my programs. However, I do understand that this all comes at a cost (not even for performance, but also for compile time!). I can't however yet bring myself to start implementing all these more efficient synonyms for these STL classes just to get 10% more performance overall. The complexity of programming grows at a large rate in that way. Maybe later.

## The case for procedural programming

the idea of Procedural programming being usurped by OOP as the definitive better option is not correct, in my opinion. Furthermore, I have recently adopted the idea that any program should start as a procedural program, and only later possibly be refactored into classes. functions that transform elements, take arguments, and so on, can operate perfectly fine outside of a class. The problem for me lies in `data` classes, if I can call them that. Suppose a 3-dimension float vector class `Vec3f`. If we would have a dot product function, would probably invoke it much akin to `lhs.dot(rhs)`. However, if `dot` would not be a member function, we would implement it as `dot(Vec3f &lhs, Vec3f const &rhs)` (where, based on implementation, we could return `void`, a reference to `&lhs` for further chaining, or a new `Vec3f result`). Now, it becomes a case of infix notation like `a + b` , or polish notation, `+ a b`. Furthermore, one could argue that this `dot` function really belongs to the class `Vec3f` because it can only deal with arguments that are `Vec3f`, and only make sense in the context of `Vec3f`. I am unsure what pattern I agree with more. However, because it is a class that contains functions, and object `vec3f` also contains a v-table pointer to its functions. In a data-oriented world, this is unwanted baggage (or more strongly termed, `wasted memory`). I am at the moment unsure whether each instantiated object contains this pointer, or only those that member functions are called on. However, it becomes obvious that if we have many instances of `Vec3f` (which in theory are only three floats stacked together), we have a lot of wasted space.

!!! note
    Above is only true if the class has virtual functions. Otherwise, most compilers infer no difference. 

 I think a solution would be to have the `dot()` function live in the namespace of `Vec3f`. I read somewhere (in a discussion of `class vs. struct`) that said __a class if it has hidden state, otherwise a struct__, which I believe to be the most sensible standpoint I have read so far. When I finished the c++ course, I had forgotten about structs. Now, I try to use them more. The quote from the discussion is similar to the idea that a struct should only contain POD (Plain Ol' Data). However, this lead me to believe that any object that requires functionality or change should be a class, which is definitely not true either.

## Triple A c++ (Almost Always Auto)

`auto` is very useful for iterators, as it allows us to just use list iteration syntax, preventing the user from over / underflowing. However, some people strive towards the Almost Always Auto convention, as necessarily, every variable needs to be initialized. Sometimes the user does not care for the type (which is also the case for iterators).
~~~~~~~~~~
auto x = int{3};
auto car = Car{a,b,c,};
for (auto &car: cars){}
auto x = make_unique<Car>; // useful for heap allocation?
~~~~~~~~~~

The convention That I got acquainted to now is to use it in places where a constructor call is necessary. The use of auto in these cases forces us to specit a specific constructor. Furthermore, using auto for iteration allows for smarter loop unrolling by the compiler. Finally, I use auto for reference types where I don't necessarily care for the type (e.g. a reference to a map of string and a particular type).

In cases where an object can be trivially constructed, I use zero initialization.

## Defer vs Destruction
The use of the `defer` keyword in languages such as Go intrigues me. While memory cleanup is still left in hands of the user (we still need to manually free allocated data), we can now place the free statement close the `malloc` equivalent statement. In the simplest case, that's interesting to force if we know an object needs to be terminated in the same scope. The question I can't properly answer is why this is better than RAII. RAII is the enforcement of ownership on the object itself, while the defer lets the ownership discussion up to the user. However, the disjoint of the `malloc` and `free` still creates problematic situations with regards to ownership.


## Using std::string or SString?

Using custom data types in a library is something that I am unsure how to handle. In general, I feel that any outward facing functions should primarily standard types. The problem with this arises due to the fact that I wanted to write my own `string` class for the `mallib` project. I can use my own implementation of `SString` (Simple String) everywhere, but that requires the caller to adhere to my re-implementation of `string`, which seems prohibitive at best. However, if we change the parameter call to `string`, and use `SString` internally, then we would need to convert between the two classes, which I don't like either. I think I will stick to std::string for now, and maybe call signatures for `const char *s` for string literals? or move constructor? I don't know.

## using `ALuint`, `uint32_t`, or `buffer`?

the buffer and source UUIDs in both openAL and openGL are of `uint32_t` type. So either the calling signature for buffers or sound sources becomes either `GLuint`, `ALuint` or I can change it to `uint32_t`. Even simpler still, we can use a typedef to have both a `buffer` or a `source` type to both be `typedef buffer uint32_t`. The problem with these types of typedefs is while they carry significance in the typename, it is not immediately obvious what exactly the type is! This is the reason I do not like typedeffing basic types. But maybe that is just me.

=======

## places

places of storages, places of generation, places of transformation, places of logic (logic or result?). Elaborate on this.


## POD vs classes

POD objects should be structs, and do not provide constructors. They are always in a valid state through default initializers. Any object that allocates memory for itself (or even for something else) should be a class, as you do not want to use them in an invalid state. There is no way to guarantee that a user will always call some sort of `init()` function on struct. That means that the author needs to be wary of any functions that he or she provides, as the onus is now on every function to verify whether the object is valid or not. Furthermore, POD objects both have a standard layout. Trivial objects are contained in a contiguous memory area, but the order of the fields is not determined.

furthermore, the fact that a class object can clean up after itself through a destructor is also incredibly useful in preventing memory leaks.

Conceptually, it IS useful to have constructors: it prevents the need for some sort of init function. However, the problem arises when multiple options of constructing an object is provided. Jon Blow solves this exact problem by only allowing one constructor to be provided. This also solves the problem of what operator new is doing (i think? not sure!).

## operator overloading, copy elision
`c` does not allow for operator overloading. It is a very useful feature, especially in numerical maths. However, it is difficult to convey what each operator actually does for non-value types.


<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>